<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pathfinder Feat Map</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="Feats.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #1a1a1a;
            color: #f0f0f0;
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .header {
            width: 100%;
            background-color: #2c2c2c;
            padding: 10px 20px;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            border-bottom: 1px solid #444;
        }
        h1 {
            font-weight: 300;
            margin: 0 20px 0 0;
            font-size: 1.5em;
        }
        .search-container {
            display: flex;
            align-items: center;
        }
        #search-box {
            padding: 8px 12px;
            border-radius: 20px;
            border: 1px solid #555;
            background-color: #333;
            color: #f0f0f0;
            font-size: 1em;
            width: 250px;
            transition: all 0.3s ease;
        }
        #search-box:focus {
            outline: none;
            border-color: #77aaff;
            box-shadow: 0 0 10px rgba(119, 170, 255, 0.5);
        }
        .legend {
            display: flex;
            flex-wrap: wrap;
            margin-left: 20px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 15px;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 5px;
        }
        svg {
            width: 100vw;
            height: calc(100vh - 55px);
            cursor: grab;
        }
        svg:active {
            cursor: grabbing;
        }
        .node {
            cursor: pointer;
        }
        .node circle {
            stroke: #fff;
            stroke-width: 1.5px;
            transition: transform 0.2s ease-out, filter 0.2s ease-out;
        }
        .node:hover circle {
            transform: scale(1.2);
            filter: drop-shadow(0 0 5px #fff);
        }
        .node text {
            pointer-events: none;
            font-size: 10px;
            fill: #ccc;
            paint-order: stroke;
            stroke: #1a1a1a;
            stroke-width: 2px;
            stroke-linecap: butt;
            stroke-linejoin: round;
        }
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            transition: stroke 0.2s ease, stroke-opacity 0.2s ease;
        }
        .tooltip {
            position: absolute;
            text-align: center;
            width: auto;
            height: auto;
            padding: 8px 12px;
            font: 12px sans-serif;
            background: #222;
            border: 1px solid #555;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .node.highlighted circle {
            stroke: #ffab40;
            stroke-width: 3px;
        }
        .node.highlighted text {
            font-weight: bold;
            fill: #ffab40;
        }
        .node.dimmed {
            opacity: 0.2;
        }
        .node.selected-prereq circle {
            stroke: #87cefa; /* Light Blue */
            stroke-width: 3px;
            filter: drop-shadow(0 0 5px #87cefa);
        }
        .node.selected-unlocked circle {
            stroke: #98fb98; /* Pale Green */
            stroke-width: 3px;
             filter: drop-shadow(0 0 5px #98fb98);
        }
        .node.selected-main circle {
             stroke: #ffeb3b; /* Yellow */
             stroke-width: 4px;
             filter: drop-shadow(0 0 8px #ffeb3b);
        }
        .link.active-prereq {
            stroke: #87cefa;
            stroke-opacity: 1;
        }
        .link.active-unlocked {
            stroke: #98fb98;
            stroke-opacity: 1;
        }
    </style>
</head>
<body>

    <div class="header">
        <h1>Pathfinder Feat Map</h1>
        <div class="search-container">
            <input type="text" id="search-box" placeholder="Search for a feat...">
        </div>
        <div class="legend">
            <div class="legend-item"><div class="legend-color" style="background-color: #4e79a7;"></div><span>General</span></div>
            <div class="legend-item"><div class="legend-color" style="background-color: #f28e2c;"></div><span>Combat</span></div>
            <div class="legend-item"><div class="legend-color" style="background-color: #e15759;"></div><span>Metamagic</span></div>
            <div class="legend-item"><div class="legend-color" style="background-color: #59a14f;"></div><span>Item Creation</span></div>
            <div class="legend-item"><div class="legend-color" style="background-color: #af7aa1;"></div><span>Racial</span></div>
            <div class="legend-item"><div class="legend-color" style="background-color: #edc949;"></div><span>Style</span></div>
        </div>
    </div>

    <svg></svg>
    <div class="tooltip"></div>

    <script>
        // --- DATA PREPARATION ---
        const featNames = new Set(featData.nodes.map(n => n.id));
        const prereqMap = new Map();
        featData.nodes.forEach(node => {
            const prereqFeats = new Set(
                (node.prereqs || "").split(/, | or /)
                .map(p => p.trim())
                .filter(p => featNames.has(p))
            );
            prereqMap.set(node.id, prereqFeats);
        });
        const memo = new Map();
        function hasPrerequisite(featId, prereqId) {
            const memoKey = `${featId}-${prereqId}`;
            if (memo.has(memoKey)) return memo.get(memoKey);
            if (!prereqMap.has(featId)) return false;
            const directPrereqs = prereqMap.get(featId);
            if (directPrereqs.has(prereqId)) {
                memo.set(memoKey, true);
                return true;
            }
            for (const p of directPrereqs) {
                if (hasPrerequisite(p, prereqId)) {
                    memo.set(memoKey, true);
                    return true;
                }
            }
            memo.set(memoKey, false);
            return false;
        }
        const links = [];
        featData.nodes.forEach(targetNode => {
            const directPrereqs = Array.from(prereqMap.get(targetNode.id) || []);
            directPrereqs.forEach(sourcePrereq => {
                const isRedundant = directPrereqs.some(otherPrereq => {
                    if (sourcePrereq === otherPrereq) return false;
                    return hasPrerequisite(otherPrereq, sourcePrereq);
                });
                if (!isRedundant) {
                    links.push({ source: sourcePrereq, target: targetNode.id });
                }
            });
        });
        const outDegrees = new Map(featData.nodes.map(node => [node.id, 0]));
        links.forEach(l => {
            outDegrees.set(l.source.id, outDegrees.get(l.source.id) + 1);
        });
        const radiusScale = d3.scaleSqrt()
            .domain([0, d3.max(Array.from(outDegrees.values()))])
            .range([6, 18]);

        // --- D3 SETUP ---
        const width = window.innerWidth;
        const height = window.innerHeight - 55;
        const svg = d3.select("svg")
            .attr("viewBox", [-width / 2, -height / 2, width, height]);
        const g = svg.append("g");
        svg.on("click", (event) => {
            if (event.target.nodeName === 'svg' || event.target.nodeName === 'g') {
                 clearHighlights();
            }
        });
        const zoom = d3.zoom().on("zoom", (event) => {
            g.attr("transform", event.transform);
        });
        svg.call(zoom);
        const tooltip = d3.select(".tooltip");
        const color = d3.scaleOrdinal(d3.schemeTableau10)
            .domain(["General", "Combat", "Metamagic", "Item Creation", "Racial", "Style"]);

        const simulation = d3.forceSimulation(featData.nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(100).strength(0.5))
            .force("charge", d3.forceManyBody().strength(-300))
            .force("x", d3.forceX().strength(0.05))
            .force("y", d3.forceY().strength(0.05))
            .on("tick", ticked);
            
        const defs = svg.append('defs');
        
        // --- DRAW ELEMENTS ---
        let link = g.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(links)
            .join("line")
            .attr("class", "link");
            
        let node = g.append("g")
            .attr("class", "nodes")
            .selectAll("g")
            .data(featData.nodes)
            .join("g")
            .attr("class", "node")
            .call(drag(simulation));

        node.append("circle")
            .attr("r", d => radiusScale(outDegrees.get(d.id)))
            // MODIFIED: Handle both string and array for group color.
            // It will use the first group in an array for coloring.
            .attr("fill", d => color(Array.isArray(d.group) ? d.group[0] : d.group));
            
        node.append("text")
            .text(d => d.id)
            .attr("x", d => radiusScale(outDegrees.get(d.id)) + 3)
            .attr("y", 3);

        // --- EVENT HANDLERS ---
        node.on("mouseover", function(event, d) {
            tooltip.transition().duration(200).style("opacity", .9);

            // MODIFIED: Display all groups in the tooltip, joined by " / ".
            const groupText = Array.isArray(d.group) ? d.group.join(' / ') : d.group;
            
            tooltip.html(`<strong>${d.id}</strong><br/><em>${groupText} Feat</em><br/><small>Prereqs: ${d.prereqs || "None"}</small>`)
                .style("left", (event.pageX + 15) + "px")
                .style("top", (event.pageY - 28) + "px");

            link
                .style('stroke', l => (l.source.id === d.id || l.target.id === d.id) ? '#ffab40' : null)
                .style('stroke-opacity', l => (l.source.id === d.id || l.target.id === d.id) ? 1 : null);
        })
        .on("mouseout", function(d) {
            tooltip.transition().duration(500).style("opacity", 0);
            if (d3.selectAll(".selected-main").empty()) {
                link.style('stroke', null).style('stroke-opacity', null);
            }
        })
        .on("click", highlightChain);

        function ticked() {
            node.attr("transform", d => `translate(${d.x},${d.y})`);
            
            link.each(function(d) {
                const targetRadius = radiusScale(outDegrees.get(d.target.id));
                const dx = d.target.x - d.source.x;
                const dy = d.target.y - d.source.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const targetX = d.target.x - (dx / distance) * (targetRadius + 5);
                const targetY = d.target.y - (dy / distance) * (targetRadius + 5);

                d3.select(this)
                    .attr("x1", d.source.x)
                    .attr("y1", d.source.y)
                    .attr("x2", targetX)
                    .attr("y2", targetY)
                    .attr('marker-end', 'url(#arrow)');
            });
        }
        
        defs.append('marker')
            .attr('id', 'arrow')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 0).attr('refY', 0)
            .attr('markerWidth', 6).attr('markerHeight', 6)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', '#999');

        function drag(simulation) {
          function dragstarted(event, d) { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
          function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
          function dragended(event, d) { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }
          return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
        }

        // --- SEARCH & HIGHLIGHT LOGIC ---
        const searchInput = d3.select("#search-box");
        searchInput.on("input", function() {
            const searchTerm = this.value.trim().toLowerCase();
            clearHighlights();
            if (searchTerm === "") {
                node.classed("dimmed", false).classed("highlighted", false);
                return;
            }
            node.classed("dimmed", true).classed("highlighted", false);
            const matchedNodes = node.filter(d => d.id.toLowerCase().includes(searchTerm));
            matchedNodes.classed("dimmed", false).classed("highlighted", true);
            if (matchedNodes.size() === 1) {
                const d = matchedNodes.datum();
                const scale = 1.5;
                const transform = d3.zoomIdentity.translate(width/2, height/2).scale(scale).translate(-d.x, -d.y);
                svg.transition().duration(750).call(zoom.transform, transform);
            }
        });
        
        function clearHighlights() {
            node.classed("dimmed", false).classed("selected-main", false).classed("selected-prereq", false).classed("selected-unlocked", false);
            link.attr("class", "link").style('stroke', null).style('stroke-opacity', null);
        }

        function highlightChain(event, d) {
            event.stopPropagation();
            clearHighlights();
            const prereqs = new Set();
            const unlocked = new Set();
            function findPrereqs(featId) {
                if (!featId || prereqs.has(featId)) return;
                prereqs.add(featId);
                links.forEach(l => { if (l.target.id === featId) findPrereqs(l.source.id); });
            }
            function findUnlocked(featId) {
                if (!featId || unlocked.has(featId)) return;
                unlocked.add(featId);
                links.forEach(l => { if (l.source.id === featId) findUnlocked(l.target.id); });
            }
            findPrereqs(d.id);
            findUnlocked(d.id);
            node.classed("dimmed", true);
            node.filter(n => prereqs.has(n.id)).classed("dimmed", false).classed("selected-prereq", true);
            node.filter(n => unlocked.has(n.id)).classed("dimmed", false).classed("selected-unlocked", true);
            d3.select(this).classed("selected-main", true).classed("selected-prereq", false).classed("selected-unlocked", false);
            link.each(function(l) {
                const sourceIsPrereq = prereqs.has(l.source.id), targetIsPrereq = prereqs.has(l.target.id);
                const sourceIsUnlocked = unlocked.has(l.source.id), targetIsUnlocked = unlocked.has(l.target.id);
                if (sourceIsPrereq && targetIsPrereq) d3.select(this).attr("class", "link active-prereq");
                if (sourceIsUnlocked && targetIsUnlocked) d3.select(this).attr("class", "link active-unlocked");
            });
        }
    </script>

</body>
</html>
